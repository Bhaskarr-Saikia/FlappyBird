<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy by Bhaskar</title>
    <!-- Use a retro-style font via Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- Tone.js for sound effects (click/jump music) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <style>
        /* General body styling for full-screen game */
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #70c5ce; /* Flappy Bird sky color */
            font-family: 'Press Start 2P', cursive;
            color: white;
            position: relative;
        }

        /* Canvas should take up the available space and be centered */
        #gameCanvas {
            background-color: #4ec0ca;
            display: block;
            border-radius: 12px;
            box-shadow: 0 10px 0 #543b35; /* Ground/border effect */
            touch-action: manipulation; /* Prevents mobile scrolling on tap */
        }

        /* Game UI elements */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            pointer-events: none; /* Allows clicks/taps to pass through unless visible */
        }

        /* Start Screen and Game Over Modal Styling */
        .modal {
            background: rgba(0, 0, 0, 0.7);
            border: 4px solid #fff;
            padding: 30px 50px;
            border-radius: 15px;
            box-shadow: 0 8px 0px 0px #543b35, 0 0 30px rgba(255, 255, 255, 0.5);
            pointer-events: auto;
            max-width: 80%;
            transition: opacity 0.3s ease;
        }

        .modal h1 {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            margin-bottom: 20px;
            color: #ffda00;
            text-shadow: 4px 4px 0 #8b0000;
        }

        .modal p {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            margin-bottom: 30px;
        }

        .modal button {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: clamp(0.9rem, 3vw, 1.3rem);
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 5px 0 #1e7e34;
            transition: all 0.1s;
            font-family: 'Press Start 2P', cursive;
        }

        .modal button:active {
            box-shadow: 0 2px 0 #1e7e34;
            transform: translateY(3px);
        }

        /* Real-time score display */
        #scoreDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: clamp(1.5rem, 5vw, 3rem);
            color: #fff;
            text-shadow: 4px 4px 0px #000;
            z-index: 10;
        }

        /* Hidden image to preload the bird asset */
        #birdImage {
	
            display: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- Score Display (Upper Left Corner) -->
    <div id="scoreDisplay">Score: 0</div>

    <!-- Bird Image (Hidden) -->
    <!-- IMPORTANT: Replace the src below with the actual path to your image.jpg.jpg file if it is not loading. -->
    <img id="birdImage" src="image.jpg.png" onerror="this.src='https://placehold.co/50x50/333333/ffffff?text=BIRD'">

    <!-- Game Over Overlay -->
    <div id="gameOverOverlay" class="game-overlay" style="display: none;">
        <div class="modal">
            <h1>Game Over!</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button onclick="startGame()">Play Again</button>
        </div>
    </div>

    <!-- Start Game Overlay -->
    <div id="startOverlay" class="game-overlay">
        <div class="modal">
            <h1>Flappy by Bhaskar</h1>
            <p>Press the SPACEBAR, click, or tap the screen to fly.</p>
            <button onclick="startGame()">Start Game</button>
        </div>
    </div>

    <script>
        // Tone.js initialization variables
        let jumpSynth;
        
        // --- Initialization and Setup ---
        // Tone.js needs to be started on a user action for the AudioContext to activate.
        document.addEventListener('DOMContentLoaded', () => {
             // A simple plucky synth for a nice jump sound
            jumpSynth = new Tone.Synth({
                oscillator: { type: "triangle" },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.01,
                    release: 0.1
                }
            }).toDestination();
        });


        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const birdImage = document.getElementById('birdImage');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const startOverlay = document.getElementById('startOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreDisplay = document.getElementById('finalScore');

        // --- Game Constants ---
        const GAME_STATE = { READY: 0, PLAYING: 1, GAME_OVER: 2 };
        let gameState = GAME_STATE.READY;
        const GRAVITY = 0.5;
        const JUMP_VELOCITY = -10;
        const INITIAL_PIPE_SPEED = 3; // Starting speed (pixels per frame)
        const SPEED_INCREASE_RATE = 0.0005; // How much speed increases per frame for difficulty scaling
        const PIPE_GAP_SIZE = 250; // Increased gap size for easier play
        const PIPE_WIDTH = 52;
        const PIPE_SPACING = 300; // Distance (pixels) between pipe generation points

        // Helper constant to convert frames needed to milliseconds, assuming 60 FPS baseline
        const AVG_FRAME_MS = 1000 / 60; 

        // --- Game Variables ---
        let bird;
        let pipes = [];
        let score = 0;
        let pipeSpeed = INITIAL_PIPE_SPEED;
        let lastTime = 0;
        let pipeTimer = 0;
        let canvasWidth, canvasHeight;

        // --- Sound Logic ---

        function playJumpSound() {
            // Start the Tone audio context if it hasn't been started (necessary for many browsers)
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            
            // Fix: Use Tone.Transport.scheduleOnce to schedule the event on the next available beat 
            // (effectively "now" in real-time) to prevent timing conflicts from rapid fire triggers.
            Tone.Transport.scheduleOnce(time => {
                jumpSynth.triggerAttackRelease("C5", "8n", time);
            }, Tone.now());
        }

        // --- Objects and Logic ---

        class Bird {
            constructor() {
                this.x = canvasWidth / 4;
                this.y = canvasHeight / 2;
                this.width = 50;
                this.height = 50;
                this.velocity = 0;
            }

            draw() {
                // Draw the bird image
                if (birdImage.complete && birdImage.naturalWidth !== 0) {
                    // Slight rotation based on velocity to simulate flying/falling
                    const maxRotation = Math.PI / 4; // 45 degrees
                    let rotation = Math.min(maxRotation, Math.max(-maxRotation, this.velocity * 0.05));

                    ctx.save();
                    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.rotate(rotation);
                    ctx.drawImage(birdImage, -this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.restore();
                } else {
                    // Fallback if image fails to load
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }

            update() {
                this.velocity += GRAVITY;
                this.y += this.velocity;
            }

            jump() {
                this.velocity = JUMP_VELOCITY;
            }
        }

        class Pipe {
            constructor(height) {
                this.x = canvasWidth;
                this.y = 0;
                this.width = PIPE_WIDTH;
                this.topHeight = height;
                this.bottomHeight = canvasHeight - height - PIPE_GAP_SIZE;
                this.scored = false;
            }

            draw() {
                // Top Pipe (Green with darker outline/shadow)
                ctx.fillStyle = '#4CAF50'; // Bright Green
                ctx.fillRect(this.x, 0, this.width, this.topHeight);
                ctx.fillStyle = '#1e7e34'; // Darker Green for shadow/border
                ctx.fillRect(this.x, 0, this.width, 10); // Top lip

                // Bottom Pipe
                const bottomY = canvasHeight - this.bottomHeight;
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(this.x, bottomY, this.width, this.bottomHeight);
                ctx.fillStyle = '#1e7e34';
                ctx.fillRect(this.x, bottomY, this.width, 10); // Bottom lip
            }

            update() {
                this.x -= pipeSpeed;
            }
        }

        function resizeCanvas() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Re-center bird on resize if game is not over
            if (bird && gameState !== GAME_STATE.GAME_OVER) {
                 bird.x = canvasWidth / 4;
            }
        }

        function generatePipe() {
            // Random height for the top pipe (ensuring room for gap and ground clearance)
            // Min top height: 50, Max top height: canvasHeight - PIPE_GAP_SIZE - 50 (50px clearance on top/bottom)
            const minHeight = 50;
            const maxHeight = canvasHeight - PIPE_GAP_SIZE - minHeight;
            // Prevent issues if screen height is too small
            if (maxHeight < minHeight) {
                console.warn("Screen height too small for comfortable pipe generation.");
                return;
            }
            const randomHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;

            pipes.push(new Pipe(randomHeight));
        }

        function checkCollision() {
            // 1. Ground and Ceiling collision
            if (bird.y + bird.height > canvasHeight || bird.y < 0) {
                return true;
            }

            // 2. Pipe collision
            for (let i = 0; i < pipes.length; i++) {
                const p = pipes[i];

                // Check if bird is horizontally aligned with the pipe
                if (bird.x < p.x + p.width && bird.x + bird.width > p.x) {
                    // Check for vertical collision with top or bottom pipe
                    const isHittingTop = bird.y < p.topHeight;
                    const isHittingBottom = bird.y + bird.height > canvasHeight - p.bottomHeight;

                    if (isHittingTop || isHittingBottom) {
                        return true;
                    }
                }
            }
            return false;
        }

        function updateScore() {
            for (let i = 0; i < pipes.length; i++) {
                const p = pipes[i];
                // Check if the pipe has passed the bird's x position and hasn't been scored yet
                if (p.x + p.width < bird.x && !p.scored) {
                    score++;
                    p.scored = true;
                    scoreDisplay.textContent = `Score: ${score}`;
                    break;
                }
            }
        }

        function gameOver() {
            gameState = GAME_STATE.GAME_OVER;
            finalScoreDisplay.textContent = score;
            gameOverOverlay.style.display = 'flex';
        }

        // --- Game Loop and Control ---

        function gameLoop(currentTime) {
            if (gameState !== GAME_STATE.PLAYING) {
                lastTime = currentTime; // Reset lastTime when not playing
                return;
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear the canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // 1. Update difficulty (gradually increase pipe speed)
            pipeSpeed += SPEED_INCREASE_RATE * deltaTime;

            // 2. Bird Update
            bird.update();
            bird.draw();

            // 3. Pipe Generation
            pipeTimer += deltaTime;
            
            // Calculate the time needed to move PIPE_SPACING pixels at the current pipeSpeed
            const framesToWait = PIPE_SPACING / pipeSpeed;
            const pipeInterval = framesToWait * AVG_FRAME_MS;

            if (pipeTimer > pipeInterval) {
                generatePipe();
                // Subtract the interval to maintain accurate timing if overshoot occurred
                pipeTimer -= pipeInterval; 
            }

            // 4. Pipes Update and Drawing
            for (let i = pipes.length - 1; i >= 0; i--) {
                const p = pipes[i];
                p.update();
                p.draw();

                // Remove off-screen pipes
                if (p.x + p.width < 0) {
                    pipes.splice(i, 1);
                }
            }

            // 5. Check for Score and Collision
            updateScore();
            if (checkCollision()) {
                gameOver();
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            // Reset state
            gameState = GAME_STATE.PLAYING;
            score = 0;
            pipeSpeed = INITIAL_PIPE_SPEED;
            pipes = [];
            bird = new Bird();
            scoreDisplay.textContent = 'Score: 0';
            lastTime = performance.now(); // Initialize for smooth loop start

            // Generate the first pipe immediately
            generatePipe(); 
            
            // Hide overlays
            startOverlay.style.display = 'none';
            gameOverOverlay.style.display = 'none';

            // Start the game loop
            requestAnimationFrame(gameLoop);
        }

        function handleJump() {
            if (gameState === GAME_STATE.READY) {
                startGame();
            } else if (gameState === GAME_STATE.PLAYING) {
                bird.jump();
                // Play sound on successful jump
                playJumpSound(); 
            } else if (gameState === GAME_STATE.GAME_OVER) {
                startGame();
            }
        }

        // --- Event Listeners ---

        // Handle Spacebar and Touch/Click
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.key === ' ') {
                e.preventDefault(); // Prevent spacebar from scrolling
                handleJump();
            }
        });

        // Handle mouse click on the canvas/body
        document.addEventListener('click', (e) => {
            // Only handle jump if click isn't on a button
            if (e.target.tagName !== 'BUTTON') {
                handleJump();
            }
        });

        // Handle touch on the canvas/body
        document.addEventListener('touchstart', (e) => {
             // Only handle jump if touch isn't on a button
            if (e.target.tagName !== 'BUTTON') {
                e.preventDefault();
                handleJump();
            }
        }, { passive: false });

        // Handle window resize for responsiveness
        window.addEventListener('resize', resizeCanvas);

        // Initial setup on load
        window.onload = function() {
            // Ensure the canvas is sized correctly initially
            resizeCanvas();

            // Wait for the bird image to load before displaying the start screen, or just proceed
            if (birdImage.complete) {
                // Image is ready, show start screen (which is the default state)
                startOverlay.style.display = 'flex';
            } else {
                birdImage.onload = () => {
                    // Image loaded later
                    if (gameState === GAME_STATE.READY) {
                        startOverlay.style.display = 'flex';
                    }
                };
                birdImage.onerror = () => {
                    console.error("Failed to load bird image. Using fallback.");
                    if (gameState === GAME_STATE.READY) {
                        startOverlay.style.display = 'flex';
                    }
                }
            }
        };

    </script>
</body>
</html>

